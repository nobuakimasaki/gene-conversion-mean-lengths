ggplot(hotspots.chr21 %>% filter(hotspot == TRUE)) +
geom_rect(aes(xmin = first_pos/10^6, xmax = last_pos/10^6, ymin = log(5*background.chr21)-0.5, ymax = log(5*background.chr21)+0.5), fill = "red", color = "red") +
geom_point(data = recomb.rates.chr21, aes(x = center/10^6, y = log(V1)), size = 0.3, alpha = 0.2) +
labs(x = "Position (kb)", y = "Logged recombination rate (cM/Mb)", title = "Recombination hotspots on chromosome 21") +
geom_hline(yintercept = log(5*background.chr21)) +
theme_bw()
ggplot(hotspots.chr21 %>% filter(hotspot == TRUE)) +
geom_rect(aes(xmin = first_pos/10^6, xmax = last_pos/10^6, ymin = log(5*background.chr21)-0.5, ymax = log(5*background.chr21)+0.5), fill = "red", color = "red") +
geom_point(data = recomb.rates.chr21, aes(x = center/10^6, y = log(V1)), size = 0.3, alpha = 0.2) +
labs(x = "Position (Mb)", y = "Logged recombination rate (cM/Mb)", title = "Recombination hotspots on chromosome 21") +
geom_hline(yintercept = log(5*background.chr21)) +
theme_bw()
ggsave("Fig2.png")
ggsave("Fig2.png", width = 7, height = 3)
ggsave("Fig2.png", width = 7, height = 4)
5*background.chr21
1/res.hotspot[[1]][[1]]
res.hotspot <- readRDS("res.UK_Biobank.1M.1500.region.5000.ibdclust2cM.MAF.0.5.boot.grouped.keep.ends.hotspot.rds")
res.not.hotspot <- readRDS("res.UK_Biobank.1M.1500.region.5000.ibdclust2cM.MAF.0.5.boot.grouped.keep.ends.not.hotspot.rds")
res <- readRDS("res.UK_Biobank.1M.1500.region.5000.ibdclust2cM.MAF.0.5.boot.grouped.keep.ends.rds")
1/res.hotspot[[1]][[1]]
1/res.not.hotspot[[1]][[1]]
1/res[[1]][[1]]
quantile(lapply(res.hotspot[[5]], function(x) {x[[1]]}) %>% unlist(), probs = c(0.025, 0.975))
quantile(lapply(res.not.hotspot[[5]], function(x) {x[[1]]}) %>% unlist(), probs = c(0.025, 0.975))
res.hotspot <- readRDS("res.UK_Biobank.1M.1500.region.5000.ibdclust2cM.MAF.0.5.boot.grouped.keep.ends.hotspot.rds")
res.not.hotspot <- readRDS("res.UK_Biobank.1M.1500.region.5000.ibdclust2cM.MAF.0.5.boot.grouped.keep.ends.not.hotspot.rds")
res <- readRDS("res.UK_Biobank.1M.1500.region.5000.ibdclust2cM.MAF.0.5.boot.grouped.keep.ends.rds")
1/res.hotspot[[1]][[1]]
1/res.not.hotspot[[1]][[1]]
1/res[[1]][[1]]
2/res.hotspot[[2]][[1]]
2/res.not.hotspot[[2]][[1]]
2/res[[2]][[1]]
res.hotspot <- readRDS("res.UK_Biobank.1M.1500.region.5000.ibdclust2cM.MAF.0.5.boot.grouped.keep.ends.hotspot.rds")
res.not.hotspot <- readRDS("res.UK_Biobank.1M.1500.region.5000.ibdclust2cM.MAF.0.5.boot.grouped.keep.ends.not.hotspot.rds")
res <- readRDS("res.UK_Biobank.1M.1500.region.5000.ibdclust2cM.MAF.0.5.boot.grouped.keep.ends.rds")
1/res.hotspot[[1]][[1]]
1/res.not.hotspot[[1]][[1]]
2/res.hotspot[[2]][[1]]
2/res.not.hotspot[[2]][[1]]
quantile(lapply(res.hotspot[[5]], function(x) {x[[1]]}) %>% unlist(), probs = c(0.025, 0.975))
quantile(lapply(res.not.hotspot[[5]], function(x) {x[[1]]}) %>% unlist(), probs = c(0.025, 0.975))
quantile(lapply(res.hotspot[[5]], function(x) {x[[2]]}) %>% unlist(), probs = c(0.025, 0.975))
quantile(lapply(res.not.hotspot[[5]], function(x) {x[[2]]}) %>% unlist(), probs = c(0.025, 0.975))
res.hotspot <- readRDS("res.UK_Biobank.1M.1500.region.5000.ibdclust2cM.MAF.0.5.boot.grouped.keep.ends.hotspot.rds")
res.not.hotspot <- readRDS("res.UK_Biobank.1M.1500.region.5000.ibdclust2cM.MAF.0.5.boot.grouped.keep.ends.not.hotspot.rds")
res <- readRDS("res.UK_Biobank.1M.1500.region.5000.ibdclust2cM.MAF.0.5.boot.grouped.keep.ends.rds")
1/res.hotspot[[1]][[1]]
2/res.hotspot[[2]][[1]]
1/res.not.hotspot[[1]][[1]]
2/res.not.hotspot[[2]][[1]]
quantile(lapply(res.hotspot[[5]], function(x) {x[[1]]}) %>% unlist(), probs = c(0.025, 0.975))
quantile(lapply(res.hotspot[[5]], function(x) {x[[2]]}) %>% unlist(), probs = c(0.025, 0.975))
quantile(lapply(res.not.hotspot[[5]], function(x) {x[[1]]}) %>% unlist(), probs = c(0.025, 0.975))
quantile(lapply(res.not.hotspot[[5]], function(x) {x[[2]]}) %>% unlist(), probs = c(0.025, 0.975))
res.hotspot[[1]]
res.hotspot[[1]][[2]]
res.hotspot[[2]][[2]]
res.hotspot[[1]][[2]]
res.hotspot[[2]][[2]]
res.hotspot[[1]][[2]]
res.hotspot[[2]][[2]]
res.not.hotspot[[1]][[2]]
res.not.hotspot[[2]][[2]]
library(ggplot2)
library(dplyr)
recomb_rates <- readRDS("res_recombination_rates.rds")
get_hotspots <- function(chr) {
recomb_rates.chr <- recomb_rates[[chr]][[1]]
background.rate <- recomb_rates[[chr]][[2]]
recomb_rates.chr$hotspot <- recomb_rates.chr$V1 > 5*background.rate
# Add a grouping column to identify consecutive TRUE/FALSE sequences
recomb_rates.chr <- recomb_rates.chr %>%
mutate(group_id = cumsum(hotspot != lag(hotspot, default = first(hotspot))))
recomb.hotspots.chr <- recomb_rates.chr %>%
group_by(group_id) %>%
summarize(
first_marker = min(V2),
last_marker = max(V3),
first_pos = min(V4),
last_pos = max(V5),
hotspot = first(hotspot)) %>%
select(-group_id)
recomb.hotspots.chr$length <- recomb.hotspots.chr$last_pos - recomb.hotspots.chr$first_pos + 1
recomb.hotspots.chr$chr <- chr
return(recomb.hotspots.chr)
}
hotspots.chrs <- lapply(1:22, get_hotspots)
saveRDS(hotspots.chrs, "hotspots.RDS")
hotspots.chrs.combined <- do.call(rbind, hotspots.chrs)
quantile(lapply(res.hotspot[[5]], function(x) {x[[1]]}) %>% unlist(), probs = c(0.025, 0.975))
quantile(lapply(res.hotspot[[5]], function(x) {x[[2]]}) %>% unlist(), probs = c(0.025, 0.975))
quantile(lapply(res.not.hotspot[[5]], function(x) {x[[1]]}) %>% unlist(), probs = c(0.025, 0.975))
quantile(lapply(res.not.hotspot[[5]], function(x) {x[[2]]}) %>% unlist(), probs = c(0.025, 0.975))
2 - 2*res.hotspot[[1]][[2]]
2 - 2*res.hotspot[[2]][[2]]
2 - 2*res.not.hotspot[[1]][[2]]
2 - 2*res.not.hotspot[[2]][[2]]
quantile(lapply(res.hotspot[[5]], function(x) {x[[1]]}) %>% unlist(), probs = c(0.025, 0.975))
quantile(lapply(res.hotspot[[5]], function(x) {x[[2]]}) %>% unlist(), probs = c(0.025, 0.975))
quantile(lapply(res.not.hotspot[[5]], function(x) {x[[1]]}) %>% unlist(), probs = c(0.025, 0.975))
quantile(lapply(res.not.hotspot[[5]], function(x) {x[[2]]}) %>% unlist(), probs = c(0.025, 0.975))
2 + 2*res.hotspot[[1]][[2]]
2 + 2*res.hotspot[[2]][[2]]
2 + 2*res.not.hotspot[[1]][[2]]
2 + 2*res.not.hotspot[[2]][[2]]
pmax(c(1,2,3,4,5), 3)
pmax(c(1,2,3,4,5), 3)
res.hotspot <- readRDS("res.UK_Biobank.1M.1500.region.5000.ibdclust2cM.MAF.0.5.boot.grouped.keep.ends.hotspot.rds")
res.not.hotspot <- readRDS("res.UK_Biobank.1M.1500.region.5000.ibdclust2cM.MAF.0.5.boot.grouped.keep.ends.not.hotspot.rds")
res <- readRDS("res.UK_Biobank.1M.1500.region.5000.ibdclust2cM.MAF.0.5.boot.grouped.keep.ends.rds")
1/res.hotspot[[1]][[1]]
2/res.hotspot[[2]][[1]]
1/res.not.hotspot[[1]][[1]]
2/res.not.hotspot[[2]][[1]]
quantile(lapply(res.hotspot[[5]], function(x) {x[[1]]}) %>% unlist(), probs = c(0.025, 0.975))
quantile(lapply(res.hotspot[[5]], function(x) {x[[2]]}) %>% unlist(), probs = c(0.025, 0.975))
quantile(lapply(res.not.hotspot[[5]], function(x) {x[[1]]}) %>% unlist(), probs = c(0.025, 0.975))
quantile(lapply(res.not.hotspot[[5]], function(x) {x[[2]]}) %>% unlist(), probs = c(0.025, 0.975))
2 + 2*res.hotspot[[1]][[2]]
2 + 2*res.hotspot[[2]][[2]]
2 + 2*res.not.hotspot[[1]][[2]]
2 + 2*res.not.hotspot[[2]][[2]]
library(data.table)
library(purrr)
library(parallel)
source("fns_sim.R")
library(data.table)
library(purrr)
library(parallel)
source("fns_sim.R")
setwd("robustness_sim/")
library(data.table)
library(purrr)
library(parallel)
source("fns_sim.R")
set.seed(26)
# Detect the number of available cores
num_cores <- detectCores()
read.MAF <- function(seed) {
str = paste0("/projects/browning/brwnlab/sharon/for_nobu/gc_length/sim5_data/sim5_seed", seed,
"_10Mb_n125000.gtstats")
df <- read.table(str)
return(df)
}
# read.MAF <- function(seed) {
#   str = paste0("sim5_seed", seed,
#                "_10Mb_n125000.gtstats")
#   df <- read.table(str)
#   return(df)
# }
boot_MLE_M <- function(x, l_lst, psi_lst, M) {
ind <- sample(1:length(l_lst), replace = TRUE)
l_lst_boot <- l_lst[ind]
psi_lst_boot <- psi_lst[ind]
optim.out.geom <- optim(0.005, neg_log_lik, psi_lst = psi_lst_boot, pL = pL_geom_2M,
l_lst = l_lst_boot, M = M, lower = 0.0001, upper = 0.05, method = "Brent")
optim.out.geom2 <- optim(0.005, neg_log_lik, psi_lst = psi_lst_boot, pL = pL_geom2_2M,
l_lst = l_lst_boot, M = M, lower = 0.0001, upper = 0.05, method = "Brent")
print("finished 1 bootstrap iteration")
return(c(1/optim.out.geom$par, 2/optim.out.geom2$par))
}
fit_model_M <- function(df, MAF.df, M, region, MAF.ceil) {
# to make indexing easier
MAF.df$pos <- MAF.df$V2 + 1
psi <- numeric(max(MAF.df$pos))
psi[c(MAF.df$pos)] <- 2*MAF.df$V11*(1-MAF.df$V11)
exc <- MAF.df[MAF.df$V11 < 0.05 | MAF.df$V11 > MAF.ceil ,]
psi[exc$pos] <- 0
# get obs tracts
df <- dplyr::select(df, -iter)
df$V1 <- df$V1 + 1
df$V2 <- df$V2 + 1
tracts_lst <- split(df, seq(nrow(df)))
psi_lst <- lapply(tracts_lst, est_psi, psi = psi, region = region, length_chrom = length(psi), debias = FALSE)
l_lst <- lapply(tracts_lst, function(x) {x[2]-x[1]+1})
keep <- which( df$V2 - df$V1 + 1 <= M & df$V2 - df$V1 + 1 > 1)
psi_lst_filt <- psi_lst[keep]
l_lst_filt <- l_lst[keep]
print(psi_lst_filt %>% unlist())
print(l_lst_filt %>% unlist())
optim.out.geom <- optim(0.005, neg_log_lik, psi_lst = psi_lst_filt, pL = pL_geom_2M,
l_lst = l_lst_filt, M = M, lower = 0.0001, upper = 0.05, method = "Brent")
optim.out.geom2 <- optim(0.005, neg_log_lik, psi_lst = psi_lst_filt, pL = pL_geom2_2M,
l_lst = l_lst_filt, M = M, lower = 0.0001, upper = 0.05, method = "Brent")
res.boot <- mclapply(1:500, boot_MLE_M, l_lst_filt, psi_lst_filt, M, mc.cores = num_cores)
print("finished 1 replicate")
print(1/optim.out.geom$par)
return(list(optim.out.geom, optim.out.geom2, l_lst, psi_lst, res.boot))
}
MAF.chrom.1 <- read.MAF(1)
tracts_geom3 <- read.csv("sim_tracts_vcf_geom3_multiple_iterations.csv")
View(tracts_geom3)
library(data.table)
library(purrr)
library(parallel)
source("fns_sim.R")
set.seed(26)
# Detect the number of available cores
num_cores <- detectCores()
read.MAF <- function(seed) {
str = paste0("/projects/browning/brwnlab/sharon/for_nobu/gc_length/sim5_data/sim5_seed", seed,
"_10Mb_n125000.gtstats")
df <- read.table(str)
return(df)
}
read.MAF <- function(seed) {
str = paste0("sim5_seed", seed,
"_10Mb_n125000.gtstats")
df <- read.table(str)
return(df)
}
boot_MLE_M <- function(x, l_lst, psi_lst, M) {
ind <- sample(1:length(l_lst), replace = TRUE)
l_lst_boot <- l_lst[ind]
psi_lst_boot <- psi_lst[ind]
optim.out.geom <- optim(0.005, neg_log_lik, psi_lst = psi_lst_boot, pL = pL_geom_2M,
l_lst = l_lst_boot, M = M, lower = 0.0001, upper = 0.05, method = "Brent")
optim.out.geom2 <- optim(0.005, neg_log_lik, psi_lst = psi_lst_boot, pL = pL_geom2_2M,
l_lst = l_lst_boot, M = M, lower = 0.0001, upper = 0.05, method = "Brent")
print("finished 1 bootstrap iteration")
return(c(1/optim.out.geom$par, 2/optim.out.geom2$par))
}
fit_model_M <- function(df, MAF.df, M, region, MAF.ceil) {
# to make indexing easier
MAF.df$pos <- MAF.df$V2 + 1
psi <- numeric(max(MAF.df$pos))
psi[c(MAF.df$pos)] <- 2*MAF.df$V11*(1-MAF.df$V11)
exc <- MAF.df[MAF.df$V11 < 0.05 | MAF.df$V11 > MAF.ceil ,]
psi[exc$pos] <- 0
# get obs tracts
df <- dplyr::select(df, -iter)
df$V1 <- df$V1 + 1
df$V2 <- df$V2 + 1
tracts_lst <- split(df, seq(nrow(df)))
psi_lst <- lapply(tracts_lst, est_psi, psi = psi, region = region, length_chrom = length(psi), debias = FALSE)
l_lst <- lapply(tracts_lst, function(x) {x[2]-x[1]+1})
keep <- which( df$V2 - df$V1 + 1 <= M & df$V2 - df$V1 + 1 > 1)
psi_lst_filt <- psi_lst[keep]
l_lst_filt <- l_lst[keep]
print(psi_lst_filt %>% unlist())
print(l_lst_filt %>% unlist())
optim.out.geom <- optim(0.005, neg_log_lik, psi_lst = psi_lst_filt, pL = pL_geom_2M,
l_lst = l_lst_filt, M = M, lower = 0.0001, upper = 0.05, method = "Brent")
optim.out.geom2 <- optim(0.005, neg_log_lik, psi_lst = psi_lst_filt, pL = pL_geom2_2M,
l_lst = l_lst_filt, M = M, lower = 0.0001, upper = 0.05, method = "Brent")
res.boot <- mclapply(1:500, boot_MLE_M, l_lst_filt, psi_lst_filt, M, mc.cores = num_cores)
print("finished 1 replicate")
print(1/optim.out.geom$par)
return(list(optim.out.geom, optim.out.geom2, l_lst, psi_lst, res.boot))
}
MAF.chrom.1 <- read.MAF(1)
tracts_geom3 <- read.csv("sim_tracts_vcf_geom3_multiple_iterations.csv")
View(MAF.chrom.1)
View(tracts_geom3)
View(MAF.chrom.1)
fit_model_M <- function(df, MAF.df, M, region, MAF.ceil) {
# to make indexing easier
MAF.df$pos <- MAF.df$V2 + 1
psi <- numeric(max(MAF.df$pos))
psi[c(MAF.df$pos)] <- 2*MAF.df$V11*(1-MAF.df$V11)
exc <- MAF.df[MAF.df$V11 < 0.05 | MAF.df$V11 > MAF.ceil ,]
psi[exc$pos] <- 0
# get obs tracts
df <- dplyr::select(df, -iter)
print(df)
df$V1 <- df$V1 + 1
df$V2 <- df$V2 + 1
tracts_lst <- split(df, seq(nrow(df)))
psi_lst <- lapply(tracts_lst, est_psi, psi = psi, region = region, length_chrom = length(psi), debias = FALSE)
l_lst <- lapply(tracts_lst, function(x) {x[2]-x[1]+1})
keep <- which( df$V2 - df$V1 + 1 <= M & df$V2 - df$V1 + 1 > 1)
psi_lst_filt <- psi_lst[keep]
l_lst_filt <- l_lst[keep]
print(psi_lst_filt %>% unlist())
print(l_lst_filt %>% unlist())
optim.out.geom <- optim(0.005, neg_log_lik, psi_lst = psi_lst_filt, pL = pL_geom_2M,
l_lst = l_lst_filt, M = M, lower = 0.0001, upper = 0.05, method = "Brent")
optim.out.geom2 <- optim(0.005, neg_log_lik, psi_lst = psi_lst_filt, pL = pL_geom2_2M,
l_lst = l_lst_filt, M = M, lower = 0.0001, upper = 0.05, method = "Brent")
res.boot <- mclapply(1:500, boot_MLE_M, l_lst_filt, psi_lst_filt, M, mc.cores = num_cores)
print("finished 1 replicate")
print(1/optim.out.geom$par)
return(list(optim.out.geom, optim.out.geom2, l_lst, psi_lst, res.boot))
}
MAF.chrom.1 <- read.MAF(1)
tracts_geom3 <- read.csv("sim_tracts_vcf_geom3_multiple_iterations.csv")
colnames(tracts_geom3) <- c("V1", "V2", "length", "iter")
tracts_geom3 <- dplyr::filter(tracts_geom3, iter <= 19)
tracts_geom3 <- dplyr::select(tracts_geom3, -length)
tracts_geom3_df_list <- split(tracts_geom3, tracts_geom3$iter)
res_geom3 <- lapply(tracts_geom3_df_list, fit_model_M, MAF.chrom.1, 1500, 5000, 0.5)
fit_model_M <- function(df, MAF.df, M, region, MAF.ceil) {
# to make indexing easier
MAF.df$pos <- MAF.df$V2 + 1
psi <- numeric(max(MAF.df$pos))
psi[c(MAF.df$pos)] <- 2*MAF.df$V11*(1-MAF.df$V11)
exc <- MAF.df[MAF.df$V11 < 0.05 | MAF.df$V11 > MAF.ceil ,]
psi[exc$pos] <- 0
# get obs tracts
df <- dplyr::select(df, -iter)
df$V1 <- df$V1 + 1
df$V2 <- df$V2 + 1
tracts_lst <- split(df, seq(nrow(df)))
psi_lst <- lapply(tracts_lst, est_psi, psi = psi, region = region, length_chrom = length(psi), debias = FALSE)
l_lst <- lapply(tracts_lst, function(x) {x[2]-x[1]+1})
print(l_lst)
keep <- which( df$V2 - df$V1 + 1 <= M & df$V2 - df$V1 + 1 > 1)
psi_lst_filt <- psi_lst[keep]
l_lst_filt <- l_lst[keep]
print(psi_lst_filt %>% unlist())
print(l_lst_filt %>% unlist())
optim.out.geom <- optim(0.005, neg_log_lik, psi_lst = psi_lst_filt, pL = pL_geom_2M,
l_lst = l_lst_filt, M = M, lower = 0.0001, upper = 0.05, method = "Brent")
optim.out.geom2 <- optim(0.005, neg_log_lik, psi_lst = psi_lst_filt, pL = pL_geom2_2M,
l_lst = l_lst_filt, M = M, lower = 0.0001, upper = 0.05, method = "Brent")
res.boot <- mclapply(1:500, boot_MLE_M, l_lst_filt, psi_lst_filt, M, mc.cores = num_cores)
print("finished 1 replicate")
print(1/optim.out.geom$par)
return(list(optim.out.geom, optim.out.geom2, l_lst, psi_lst, res.boot))
}
res_geom3 <- lapply(tracts_geom3_df_list, fit_model_M, MAF.chrom.1, 1500, 5000, 0.5)
tracts_geom3
MAF.chrom.1[MAF.chrom.1$V2 == 7937095]
MAF.chrom.1[MAF.chrom.1$V2 == 7937095,]
MAF.chrom.1[MAF.chrom.1$V2 == 9408507,]
fit_model_M <- function(df, MAF.df, M, region, MAF.ceil) {
# to make indexing easier
MAF.df$pos <- MAF.df$V2 + 1
psi <- numeric(max(MAF.df$pos))
psi[c(MAF.df$pos)] <- 2*MAF.df$V11*(1-MAF.df$V11)
exc <- MAF.df[MAF.df$V11 < 0.05 | MAF.df$V11 > MAF.ceil ,]
psi[exc$pos] <- 0
# get obs tracts
df <- dplyr::select(df, -iter)
df$V1 <- df$V1 + 1
df$V2 <- df$V2 + 1
tracts_lst <- split(df, seq(nrow(df)))
psi_lst <- lapply(tracts_lst, est_psi, psi = psi, region = region, length_chrom = length(psi), debias = FALSE)
l_lst <- lapply(tracts_lst, function(x) {x[2]-x[1]+1})
keep <- which( df$V2 - df$V1 + 1 <= M & df$V2 - df$V1 + 1 > 1)
psi_lst_filt <- psi_lst[keep]
l_lst_filt <- l_lst[keep]
print(psi_lst_filt %>% unlist())
print(l_lst_filt %>% unlist())
print(psi[9408508])
optim.out.geom <- optim(0.005, neg_log_lik, psi_lst = psi_lst_filt, pL = pL_geom_2M,
l_lst = l_lst_filt, M = M, lower = 0.0001, upper = 0.05, method = "Brent")
optim.out.geom2 <- optim(0.005, neg_log_lik, psi_lst = psi_lst_filt, pL = pL_geom2_2M,
l_lst = l_lst_filt, M = M, lower = 0.0001, upper = 0.05, method = "Brent")
res.boot <- mclapply(1:500, boot_MLE_M, l_lst_filt, psi_lst_filt, M, mc.cores = num_cores)
print("finished 1 replicate")
print(1/optim.out.geom$par)
return(list(optim.out.geom, optim.out.geom2, l_lst, psi_lst, res.boot))
}
res_geom3 <- lapply(tracts_geom3_df_list, fit_model_M, MAF.chrom.1, 1500, 5000, 0.5)
tracts_unif <- read.csv("sim_tracts_vcf_unif_multiple_iterations.csv")
View(tracts_unif)
ggplot(res.sim.CI, aes(x = index, y = est., color = model)) + geom_point() + geom_errorbar(aes(ymin = lower.95, ymax = upper.95)) + geom_hline(yintercept = 300, linetype  = 2, alpha = 0.5) + ylim(0, 500) + theme_bw() + labs(x = "Replicate", y = "Estimate", title = "Estimated mean gene conversion length from simulation study", color = "Analysis") + scale_color_manual(values = c("Geometric" = "#E41A1C", "Sum of Geometric" = "#377EB8"))
library(ggplot2)
library(purrr)
library(dplyr)
library(tidyr)
res.sim <- readRDS("res.sim.2M.1500.region.5000.ibdclust2cM.MAF.0.5.boot.keep.ends.rds")
### point estimates
par.list <- lapply(res.sim, function(x) {x[[1]][[1]]}) %>% unlist()
par.list2 <- lapply(res.sim, function(x) {x[[2]][[1]]}) %>% unlist()
### point estimates are scaled differently for the two distributions
est.geom <- 1/par.list
est.geom2 <- 2/par.list2
est.df <- c(est.geom, est.geom2) %>% as.data.frame()
colnames(est.df) <- c("est.")
### bootstrapped estimates
boot.res.list <- lapply(res.sim, function(x) {x[[5]]})
### get quantiles of raw estimates
get_CI <- function(x) {x %>% unlist() %>% matrix(ncol = 2, byrow = TRUE) %>% apply(2, function(y) quantile(y, probs = c(0.025, 0.975))) %>% unlist()}
CI.df <- lapply(boot.res.list, get_CI) %>% unlist() %>% matrix(ncol = 2, byrow = TRUE) %>% as.data.frame()
colnames(CI.df) <- c("lower.95", "upper.95")
CI.df.geom <- CI.df[seq(1,39,2),]
CI.df.geom2 <- CI.df[seq(2,40,2),]
new.CI.df <- rbind(CI.df.geom, CI.df.geom2)
### combine point estimates and CI
res.sim.CI <- cbind(est.df, new.CI.df)
res.sim.CI$index <- rep(c(1:20), 2)
res.sim.CI$model <- c(rep("Geometric", 20), rep("Sum of Geometric", 20))
ggplot(res.sim.CI, aes(x = index, y = est., color = model)) + geom_point() + geom_errorbar(aes(ymin = lower.95, ymax = upper.95)) + geom_hline(yintercept = 300, linetype  = 2, alpha = 0.5) + ylim(0, 500) + theme_bw() + labs(x = "Replicate", y = "Estimate", title = "Estimated mean gene conversion length from simulation study", color = "Analysis") + scale_color_manual(values = c("Geometric" = "#E41A1C", "Sum of Geometric" = "#377EB8"))
ggsave("figs/est.sim.png", width = 7, height = 4)
### organize psi list
# psi.list <- lapply(res.sim, function(x) {x[[3]]})
# psi.sim <- psi.list[1:20] %>% unlist()
# psi.sim2 <- psi.list[21:40] %>% unlist()
# psi.sim.keep <- psi.list[41:60] %>% unlist()
# psi.sim2.keep <- psi.list[61:80] %>% unlist()
# psi.df <- cbind(psi.sim, psi.sim2, psi.sim.keep, psi.sim2.keep)
c(2,3,4)[2.2]
c(2,3,4)[2,2]
c(2,3,4)[c(2,2)]
est_psi <- function(observed, psi, region, length_chrom, debias) {
leftmost <- max(observed[1] - region, 1)
rightmost <- min(observed[2] + region, length_chrom)
index <- leftmost:rightmost
if (debias == TRUE) {
if (observed[1] != observed[2]) {
index <- setdiff(index, observed[1])
}
}
return(mean(psi[index]))
}
est_psi(c(1), c(1,2,3,4,5), region = 2, length_chrom = 5, debias = FALSE)
est_psi(c(1,1), c(1,2,3,4,5), region = 2, length_chrom = 5, debias = FALSE)
est_psi(c(1,1), c(1,2,3,4,5), region = 3, length_chrom = 5, debias = FALSE)
library(ggplot2)
library(purrr)
library(dplyr)
library(tidyr)
res.sim <- readRDS("res.sim.2M.1500.region.5000.ibdclust2cM.MAF.0.5.boot.keep.ends.rds")
### point estimates
par.list <- lapply(res.sim, function(x) {x[[1]][[1]]}) %>% unlist()
par.list2 <- lapply(res.sim, function(x) {x[[2]][[1]]}) %>% unlist()
### point estimates are scaled differently for the two distributions
est.geom <- 1/par.list
est.geom2 <- 2/par.list2
est.df <- c(est.geom, est.geom2) %>% as.data.frame()
colnames(est.df) <- c("est.")
### bootstrapped estimates
boot.res.list <- lapply(res.sim, function(x) {x[[5]]})
### get quantiles of raw estimates
get_CI <- function(x) {x %>% unlist() %>% matrix(ncol = 2, byrow = TRUE) %>% apply(2, function(y) quantile(y, probs = c(0.025, 0.975))) %>% unlist()}
CI.df <- lapply(boot.res.list, get_CI) %>% unlist() %>% matrix(ncol = 2, byrow = TRUE) %>% as.data.frame()
colnames(CI.df) <- c("lower.95", "upper.95")
CI.df.geom <- CI.df[seq(1,39,2),]
CI.df.geom2 <- CI.df[seq(2,40,2),]
new.CI.df <- rbind(CI.df.geom, CI.df.geom2)
### combine point estimates and CI
res.sim.CI <- cbind(est.df, new.CI.df)
res.sim.CI$index <- rep(c(1:20), 2)
res.sim.CI$model <- c(rep("Geometric", 20), rep("Sum of Geometric", 20))
test <- function(x) {x %>% unlist() %>% matrix(ncol = 2, byrow = TRUE)}
test(boot.res.list[[1]])
CI.df <- lapply(boot.res.list, get_CI) %>% unlist() %>% matrix(ncol = 2, byrow = TRUE) %>% as.data.frame()
View(CI.df)
### mean estimate for all settings
res.sim.CI %>% group_by(model) %>% summarize(mean_est = mean(est.))
### filter geom and keep
res.sim.CI.geom <- res.sim.CI %>% filter(model == "geom")
### look at how many contained the true value
which(res.sim.CI.geom$lower.95 <= 300 & res.sim.CI.geom$upper.95 >= 300)
length(which(res.sim.CI.geom$lower.95 <= 300 & res.sim.CI.geom$upper.95 >= 300))
which(res.sim.CI$lower.95 <= 300 & res.sim.CI$upper.95 >= 300)
length(which(res.sim.CI$lower.95 <= 300 & res.sim.CI$upper.95 >= 300))
### look at how many contained the true value
which(res.sim.CI.geom$lower.95 <= 300 & res.sim.CI.geom$upper.95 >= 300)
length(which(res.sim.CI.geom$lower.95 <= 300 & res.sim.CI.geom$upper.95 >= 300))
which(res.sim.CI$lower.95 <= 300 & res.sim.CI$upper.95 >= 300)
length(which(res.sim.CI$lower.95 <= 300 & res.sim.CI$upper.95 >= 300))
which(res.sim.CI$lower.95 <= 300 & res.sim.CI$upper.95 >= 300)
length(which(res.sim.CI$lower.95 <= 300 & res.sim.CI$upper.95 >= 300))
### look at how many contained the true value
which(res.sim.CI.geom$lower.95 <= 300 & res.sim.CI.geom$upper.95 >= 300)
length(which(res.sim.CI.geom$lower.95 <= 300 & res.sim.CI.geom$upper.95 >= 300))
### mean estimate for all settings
res.sim.CI %>% group_by(model) %>% summarize(mean_est = mean(est.))
### filter geom and keep
res.sim.CI.geom <- res.sim.CI %>% filter(model == "geom")
### look at how many contained the true value
which(res.sim.CI.geom$lower.95 <= 300 & res.sim.CI.geom$upper.95 >= 300)
length(which(res.sim.CI.geom$lower.95 <= 300 & res.sim.CI.geom$upper.95 >= 300))
which(res.sim.CI$lower.95 <= 300 & res.sim.CI$upper.95 >= 300)
length(which(res.sim.CI$lower.95 <= 300 & res.sim.CI$upper.95 >= 300))
### mean estimate for all settings
res.sim.CI %>% group_by(model) %>% summarize(mean_est = mean(est.))
### filter geom and keep
res.sim.CI.geom <- res.sim.CI %>% filter(model == "Geometric")
### look at how many contained the true value
which(res.sim.CI.geom$lower.95 <= 300 & res.sim.CI.geom$upper.95 >= 300)
length(which(res.sim.CI.geom$lower.95 <= 300 & res.sim.CI.geom$upper.95 >= 300))
which(res.sim.CI$lower.95 <= 300 & res.sim.CI$upper.95 >= 300)
length(which(res.sim.CI$lower.95 <= 300 & res.sim.CI$upper.95 >= 300))
### list of negative log likelihoods
lik.list.geom <- lapply(res.sim, function(x) {x[[1]][[2]]}) %>% unlist()
lik.list.geom2 <- lapply(res.sim, function(x) {x[[2]][[2]]}) %>% unlist()
AIC.geom <- 2 + 2*lik.list.geom
AIC.geom2 <- 2 + 2*lik.list.geom2
### calculate AIC
res.sim.CI$AIC <- c(AIC.geom, AIC.geom2)
AIC.geom - AIC.geom2
quantile(AIC.geom - AIC.geom2)
### list of negative log likelihoods
lik.list.geom <- lapply(res.sim, function(x) {x[[1]][[2]]}) %>% unlist()
lik.list.geom2 <- lapply(res.sim, function(x) {x[[2]][[2]]}) %>% unlist()
AIC.geom <- 2 + 2*lik.list.geom
AIC.geom2 <- 2 + 2*lik.list.geom2
### calculate AIC
res.sim.CI$AIC <- c(AIC.geom, AIC.geom2)
AIC.geom - AIC.geom2
quantile(AIC.geom - AIC.geom2)
read_map_file <- function(chr) {
str = paste0("decode2019.chrchr", chr,
".GRCh38.map")
df <- read.table(str)
return(df)
}
map_list <- list()
for (i in 1:22) {
# Construct the chromosome name as a string
chr_name <- paste0("chr", i, ".map")
# Read the map file and store it in the list
map_list[[chr_name]] <- read_map_file(as.character(i))
}
setwd("hotspots")
getwd()
