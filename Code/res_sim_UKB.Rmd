---
title: "results_sim_UKB"
author: "Nobuaki Masaki"
date: "6/17/2024"
output: html_document
---

```{r}
library(ggplot2)
library(purrr)
library(dplyr)
library(tidyr)

res.sim <- readRDS("res.sim.1M.1500.region.5000.geom.ibdclust2cM.MAF.0.5.boot.rds")
res.sim2 <- readRDS("res.sim.1M.1500.region.5000.geom2.ibdclust2cM.MAF.0.5.boot.rds")
res.sim.keep <- readRDS("res.sim.1M.1500.region.5000.geom.ibdclust2cM.MAF.0.5.boot.keep.ends.rds")
res.sim2.keep <- readRDS("res.sim.1M.1500.region.5000.geom2.ibdclust2cM.MAF.0.5.boot.keep.ends.rds")

### combining results from different settings (distributions and averaging for psi)
res.sim <- c(res.sim, res.sim.keep, res.sim2, res.sim2.keep)
```

```{r}
### point estimates
par.list <- lapply(res.sim, function(x) {x[[1]][[1]]}) %>% unlist()

### point estimates are scaled differently for the two distributions
par.list1 <- 1/par.list[1:40]
par.list2 <- 2/par.list[41:80]
par.list <- c(par.list1, par.list2)

### bootstrapped estimates
boot.res.list <- lapply(res.sim, function(x) {x[[4]]}) 
### get quantiles of raw estimates
get_CI <- function(y) {lapply(y, function(x) {x[[1]][[1]][[1]]}) %>% unlist() %>% quantile(probs = c(0.025, 0.975))}
CI.list <- lapply(boot.res.list, get_CI)

### scale CIs separately for the two distributions
CI.df <- 1/(CI.list[1:40] %>% unlist %>% matrix(ncol = 2, byrow = TRUE)) 
CI2.df <- 2/(CI.list[41:80] %>% unlist %>% matrix(ncol = 2, byrow = TRUE))
CI.df <- rbind(CI.df, CI2.df)

### combine point estimates and CI
res.sim.CI <- cbind(par.list, CI.df) %>% as.data.frame()
colnames(res.sim.CI) <- c("est", "upper 95", "lower 95")
res.sim.CI$index <- rep(1:20, 4)
res.sim.CI$dist <- c(rep("geom", 40), rep("geom2", 40))
res.sim.CI$keep <- c(rep(FALSE, 20), rep(TRUE, 20), rep(FALSE, 20), rep(TRUE, 20))
```

```{r}
### organize psi list
psi.list <- lapply(res.sim, function(x) {x[[3]]}) 
psi.sim <- psi.list[1:20] %>% unlist()
psi.sim2 <- psi.list[21:40] %>% unlist()
psi.sim.keep <- psi.list[41:60] %>% unlist()
psi.sim2.keep <- psi.list[61:80] %>% unlist()
psi.df <- cbind(psi.sim, psi.sim2, psi.sim.keep, psi.sim2.keep)
```

```{r}
### plots, one without filtering by keep
ggplot(res.sim.CI, aes(x = index, y = est, color = dist, shape = keep)) + geom_point() + geom_errorbar(aes(ymin = `lower 95`, ymax = `upper 95`)) + geom_hline(yintercept = 300, linetype  = 2, alpha = 0.5) + ylim(0, 500) + theme_bw() + labs(x = "Replicate", y = "Estimate", title = "Estimated mean gene conversion length from simulation study", color = "Distribution", shape = "Keep both ends")
ggsave("est.sim.png", width = 7, height = 4)

ggplot(res.sim.CI %>% filter(keep == TRUE), aes(x = index, y = est, color = dist)) + geom_point() + geom_errorbar(aes(ymin = `lower 95`, ymax = `upper 95`)) + geom_hline(yintercept = 300, linetype  = 2, alpha = 0.5) + ylim(0, 500) + theme_bw() + labs(x = "Replicate", y = "Estimate", title = "Estimated mean gene conversion length from simulation study", color = "Distribution", shape = "Keep both ends") + scale_color_discrete(labels = c("Geometric", "Sum of two geometric"))
ggsave("est.sim2.png", width = 7, height = 4)
```

```{r}
### mean estimate for all settings
res.sim.CI %>% group_by(dist, keep) %>% summarize(mean_est = mean(est))

### filter geom and keep
res.sim.CI.geom.keep <- res.sim.CI %>% filter(dist == "geom", keep == TRUE)

### look at how many contained the true value
which(res.sim.CI.geom.keep$`lower 95` <= 300 & res.sim.CI.geom.keep$`upper 95` >= 300)
```

```{r}
### list of negative log likelihoods
lik.list <- lapply(res.sim, function(x) {x[[1]][[2]]}) %>% unlist()
### calculate AIC
res.sim.CI$AIC <- 2 + 2*lik.list

### calculate difference in AIC
res.sim.CI.filt <- res.sim.CI %>% filter(keep == TRUE)
res.sim.CI.filt <- select(res.sim.CI.filt, -dist)
res.sim.CI.filt2 <- res.sim.CI.filt[21:40,]
res.sim.CI.filt <- res.sim.CI.filt[1:20,]
colnames(res.sim.CI.filt) <- c(colnames(res.sim.CI.filt)[1:5], "AIC.geom")
res.sim.CI.filt$AIC.geom2 <- res.sim.CI.filt2$AIC
res.sim.CI.filt$AIC.diff <- res.sim.CI.filt$AIC.geom2 - res.sim.CI.filt$AIC.geom

### difference in AIC?
ggplot(res.sim.CI.filt %>% filter(keep == TRUE), aes(x = index, y = AIC.diff)) + geom_point() + theme_bw() + labs(x = "Replicate", y = "AIC", title = "AIC of both models from simulation study")

quantile(res.sim.CI.filt$AIC.diff)
```

```{r}
### UK Biobank results (ends are kept, but ran using both distributions)
res.UK <- readRDS("res.UK_Biobank.1M.1500.region.5000.geom.ibdclust2cM.MAF.0.5.boot.grouped.keep.ends.rds")

### point estimate
res.UK.phi <- 1/res.UK[[1]]$par

### bootstrapped estimates
boot.UK.res.list <- res.UK[[4]]
boot.UK.phi.inv <- lapply(boot.UK.res.list, function(x) {x[[1]][[1]]}) %>% unlist()
boot.UK.phi <- 1/boot.UK.phi.inv

res.UK.phi
boot.UK.phi %>% unlist() %>% quantile(probs = c(0.025, 0.975))
```

```{r}
res.UK2 <- readRDS("res.UK_Biobank.1M.1500.region.5000.geom2.ibdclust2cM.MAF.0.5.boot.grouped.keep.ends.rds")

### point estimate
res.UK2.phi <- 2/res.UK2[[1]]$par

### bootstrapped estimates
boot.UK2.res.list <- res.UK2[[4]]
boot.UK2.phi.inv <- lapply(boot.UK2.res.list, function(x) {x[[1]][[1]]}) %>% unlist()
boot.UK2.phi <- 2/boot.UK2.phi.inv

res.UK2.phi
boot.UK2.phi %>% unlist() %>% quantile(probs = c(0.025, 0.975))
```

```{r}
res.UK.lik <- res.UK[[1]]$value
res.UK2.lik <- res.UK2[[1]]$value

2 + 2*res.UK.lik #AIC for geom
2 + 2*res.UK2.lik #AIC for geom2
```

